from flask import Blueprint, request, jsonify
from app import db
from app.models import Vulnerability, AssetVulnerability, Asset, VulnerabilityAssessment
from datetime import datetime
import json

bp = Blueprint('vulnerability_bp', __name__, url_prefix='/api/vulnerabilities')

@bp.route('/', methods=['GET'])
def get_vulnerabilities():
    vulnerabilities = Vulnerability.query.all()
    return jsonify([vulnerability.to_dict() for vulnerability in vulnerabilities])

@bp.route('/<vulnerability_id>', methods=['GET'])
def get_vulnerability(vulnerability_id):
    vulnerability = Vulnerability.query.get_or_404(vulnerability_id)
    return jsonify(vulnerability.to_dict())

@bp.route('/', methods=['POST'])
def create_vulnerability():
    data = request.get_json()
    
    # Автогенерация ID если не указан
    vuln_id = data.get('id')
    if not vuln_id:
        # Генерируем ID на основе максимального существующего
        max_id = db.session.query(db.func.max(db.cast(Vulnerability.id, db.Integer))).scalar()
        vuln_id = str((max_id or 0) + 1)
    
    # Преобразуем строку даты в объект даты
    discovered_at = None
    if data.get('discovered_at'):
        discovered_at = datetime.fromisoformat(data['discovered_at'].replace('Z', '+00:00')).date()
    
    vulnerability = Vulnerability(
        id=vuln_id,
        name=data.get('name'),
        description=data.get('description'),
        software_name=data.get('software_name'),
        software_version=data.get('software_version'),
        vendor=data.get('vendor'),
        platform=data.get('platform'),
        discovered_at=discovered_at,
        level=data.get('level'),
        exploit_available=data.get('exploit_available', False),
        fix_info=data.get('fix_info'),
        cve=data.get('cve'),
        cwe=data.get('cwe'),
        cvss_score=data.get('cvss_score'),
        imported_from_bdu=data.get('imported_from_bdu', False)
    )
    
    db.session.add(vulnerability)
    db.session.commit()
    
    return jsonify(vulnerability.to_dict()), 201

@bp.route('/<vulnerability_id>', methods=['PUT'])
def update_vulnerability(vulnerability_id):
    vulnerability = Vulnerability.query.get_or_404(vulnerability_id)
    data = request.get_json()
    
    # Обновляем поля, если они присутствуют в запросе
    for field in ['name', 'description', 'software_name', 'software_version', 'vendor',
                  'platform', 'level', 'exploit_available', 'fix_info',
                  'cve', 'cwe', 'cvss_score']:
        if field in data:
            setattr(vulnerability, field, data[field])
    
    # Обработка даты
    if 'discovered_at' in data:
        if data['discovered_at']:
            vulnerability.discovered_at = datetime.fromisoformat(data['discovered_at'].replace('Z', '+00:00')).date()
        else:
            vulnerability.discovered_at = None
    
    db.session.commit()
    
    return jsonify(vulnerability.to_dict())

@bp.route('/<vulnerability_id>', methods=['DELETE'])
def delete_vulnerability(vulnerability_id):
    vulnerability = Vulnerability.query.get_or_404(vulnerability_id)

    # Удаление связанных записей в asset_vulnerabilities
    asset_vulnerabilities = AssetVulnerability.query.filter_by(vulnerability_id=vulnerability_id).all()
    for asset_vulnerability in asset_vulnerabilities:
        db.session.delete(asset_vulnerability)
    
    # Удаление связанных записей в vulnerability_assessment
    vulnerability_assessments = VulnerabilityAssessment.query.filter_by(vulnerability_id=vulnerability_id).all()
    for va in vulnerability_assessments:
        db.session.delete(va)

    db.session.delete(vulnerability)
    db.session.commit()

    return '', 204

@bp.route('/assets', methods=['GET'])
def get_assets_vulnerabilities():
    assets = Asset.query.all()
    result = []
    for asset in assets:
        asset_dict = asset.to_dict()
        asset_dict['vulnerabilities'] = [av.vulnerability.to_dict() for av in asset.asset_vulnerabilities if av.vulnerability_id]
        result.append(asset_dict)
    return jsonify(result)

@bp.route('/save-vulnerability-scale', methods=['POST'])
def save_vulnerability_scale():
    """
    Сохранение качественной шкалы оценки уязвимостей (шаг 2)
    """
    try:
        data = request.get_json()
        scale_data = data.get('scale', [])
        asset_id = data.get('asset_id')
        
        if not scale_data or not asset_id:
            return jsonify({'error': 'Требуются scale и asset_id'}), 400
        
        # Ищем существующую запись шкалы для этого актива (vulnerability_id = NULL)
        existing_scale = AssetVulnerability.query.filter_by(
            asset_id=asset_id,
            vulnerability_id=None
        ).first()
        
        scale_json = json.dumps(scale_data)
        
        if existing_scale:
            existing_scale.scale_json = scale_json
        else:
            # Если нет записи, создаем новую с NULL для vulnerability_id
            av = AssetVulnerability(
                asset_id=asset_id,
                vulnerability_id=None,
                scale_json=scale_json
            )
            db.session.add(av)
        
        db.session.commit()
        return jsonify({'message': 'Шкала успешно сохранена'}), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@bp.route('/get-vulnerability-scale', methods=['GET'])
def get_vulnerability_scale():
    """
    Получение качественной шкалы оценки уязвимостей (шаг 2)
    """
    asset_id = request.args.get('asset_id', type=int)
    
    if asset_id:
        # Ищем шкалу для конкретного актива (vulnerability_id = NULL)
        av = AssetVulnerability.query.filter_by(asset_id=asset_id, vulnerability_id=None).first()
        if av and av.scale_json:
            return jsonify(json.loads(av.scale_json))
    
    # Если asset_id не указан или шкала не найдена, ищем любую шкалу
    av = AssetVulnerability.query.filter(
        AssetVulnerability.scale_json.isnot(None),
        AssetVulnerability.vulnerability_id.is_(None)
    ).first()
    if av and av.scale_json:
        return jsonify(json.loads(av.scale_json))
    
    return jsonify([])

@bp.route('/save-asset-vulnerabilities', methods=['POST'])
def save_asset_vulnerabilities():
    """
    Сохранение связей актив-уязвимость (шаг 2)
    """
    try:
        data = request.get_json()
        assessments = data.get('assessments', [])
        scale = data.get('scale', [])
        
        for item in assessments:
            asset_id = item.get('asset_id')
            vulnerabilities = item.get('vulnerabilities', [])
            
            # Удаляем старые связи (кроме шкалы)
            AssetVulnerability.query.filter(
                AssetVulnerability.asset_id == asset_id,
                AssetVulnerability.vulnerability_id.isnot(None)
            ).delete()
            
            # Сохраняем шкалу
            scale_json = json.dumps(scale) if scale else None
            
            # Находим или создаем запись шкалы
            existing_scale = AssetVulnerability.query.filter_by(
                asset_id=asset_id,
                vulnerability_id=None
            ).first()
            
            if existing_scale:
                existing_scale.scale_json = scale_json
            else:
                av_scale = AssetVulnerability(
                    asset_id=asset_id,
                    vulnerability_id=None,
                    scale_json=scale_json
                )
                db.session.add(av_scale)
            
            # Создаем новые связи
            for vuln_id in vulnerabilities:
                av = AssetVulnerability(
                    asset_id=asset_id,
                    vulnerability_id=str(vuln_id),
                    scale_json=None
                )
                db.session.add(av)
        
        db.session.commit()
        return jsonify({'message': 'Связи актив-уязвимость успешно сохранены'}), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@bp.route('/save-vulnerability-assessments', methods=['POST'])
def save_vulnerability_assessments():
    """
    Сохранение оценок уязвимостей (шаг 3)
    Сохраняет в AssetVulnerability и ДОПОЛНИТЕЛЬНО в VulnerabilityAssessment
    """
    try:
        data = request.get_json()
        assessments = data.get('assessments', [])
        
        for item in assessments:
            asset_id = item.get('asset_id')
            vulnerability_id = str(item.get('vulnerability_id'))
            level = item.get('level')
            
            # Пропускаем пустые vulnerability_id
            if not vulnerability_id or vulnerability_id == 'undefined':
                continue
            
            # Проверяем, существует ли запись в AssetVulnerability
            existing_av = AssetVulnerability.query.filter_by(
                asset_id=asset_id,
                vulnerability_id=vulnerability_id
            ).first()
            
            if existing_av:
                existing_av.assessment = level
            else:
                # Если связи нет, создаем её
                av = AssetVulnerability(
                    asset_id=asset_id,
                    vulnerability_id=vulnerability_id,
                    assessment=level
                )
                db.session.add(av)
            
            # ДОПОЛНИТЕЛЬНО сохраняем в VulnerabilityAssessment
            existing_va = VulnerabilityAssessment.query.filter_by(
                asset_id=asset_id,
                vulnerability_id=vulnerability_id
            ).first()
            
            if existing_va:
                existing_va.assessment_level = level
            else:
                # Создаем новую запись в VulnerabilityAssessment
                va = VulnerabilityAssessment(
                    asset_id=asset_id,
                    vulnerability_id=vulnerability_id,
                    assessment_level=level
                )
                db.session.add(va)
        
        db.session.commit()
        return jsonify({'message': 'Оценки уязвимостей успешно сохранены'}), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@bp.route('/asset-vulnerabilities', methods=['GET'])
def get_asset_vulnerabilities():
    """
    Получение всех связей актив-уязвимость с оценками
    """
    asset_vulns = AssetVulnerability.query.filter(
        AssetVulnerability.vulnerability_id.isnot(None)
    ).all()
    result = []
    for av in asset_vulns:
        vuln = Vulnerability.query.get(av.vulnerability_id)
        asset = Asset.query.get(av.asset_id)
        result.append({
            'id': av.id,
            'asset_id': av.asset_id,
            'asset_name': asset.name if asset else '',
            'asset_type': asset.type if asset else '',
            'vulnerability_id': av.vulnerability_id,
            'vulnerability_name': vuln.name if vuln else '',
            'vulnerability_description': vuln.description if vuln else '',
            'level': av.level,
            'assessment': av.assessment,
            'created_at': av.created_at.isoformat() if av.created_at else None
        })
    return jsonify(result)

@bp.route('/vulnerability-assessments', methods=['GET'])
def get_vulnerability_assessments():
    """
    Получение всех оценок из таблицы VulnerabilityAssessment
    """
    assessments = VulnerabilityAssessment.query.all()
    result = []
    for va in assessments:
        asset = Asset.query.get(va.asset_id)
        vuln = Vulnerability.query.get(va.vulnerability_id)
        result.append({
            'id': va.id,
            'asset_id': va.asset_id,
            'asset_name': asset.name if asset else '',
            'vulnerability_id': va.vulnerability_id,
            'vulnerability_name': vuln.name if vuln else '',
            'assessment_level': va.assessment_level,
            'created_at': va.created_at.isoformat() if va.created_at else None
        })
    return jsonify(result)